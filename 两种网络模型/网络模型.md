# hero


![image-20230304210947804](assets/image-20230304210947804.png)

## Reactor

作者：小林coding
链接：https://www.zhihu.com/question/26943938/answer/1856426252
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 演进

**如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程**。

其实创建进程也是可以的，原理是一样的，进程和线程的区别在于线程比较轻量级些，线程的创建和线程间切换的成本要小些，为了描述简述，后面都以线程为例。

**处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的**。

要这么解决这个问题呢？我们可以使用「**(线程)资源复用**」的方式。

也就是不用再为每个连接创建线程，而是创建一个「线程池」，将连接分配给线程，然后一个线程可以处理多个连接的业务。

**不过，这样又引来一个新的问题，线程怎样才能高效地处理多个连接的业务**？

当一个连接对应一个线程时，线程一般采用「read -> 业务处理 -> send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 `read` 操作上（ socket 默认情况是阻塞 I/O），不过这种阻塞方式并不影响其他线程。

**但是引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的 `read` 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务**。

**要解决这一个问题，最简单的方式就是将 [socket](https://www.zhihu.com/search?q=socket&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252}) 改成非阻塞，然后线程不断地轮询调用 `read` 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低**。

**==上面的问题在于，线程并不知道当前连接是否有数据可读，从而需要每次通过 `read` 去试探==**。

**==那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I/O 多路复用==**。

I/O [多路复用技术](https://www.zhihu.com/search?q=多路复用技术&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})会用一个[系统调用](https://www.zhihu.com/search?q=系统调用&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})函数来监听我们所有关心的连接，**也就说可以在==一个监控线程==里面监控很多的连接**。

![image-20230304211222072](assets/image-20230304211222072.png)

我们熟悉的 select/poll/epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。

> PS：如果想知道 select/poll/epoll 的区别，可以看看小林之前写的这篇文章：[这次答应我，一举拿下 I/O 多路复用！](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)

在获取事件时，先把我们要关心的连接传给内核，再由[内核检测](https://www.zhihu.com/search?q=内核检测&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})：

- **==如果没有事件发生，线程只需阻塞在这个系统调用(select,poll,epoll)==**，而无需像前面的[线程池](https://www.zhihu.com/search?q=线程池&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})方案那样轮训调用 read 操作来判断是否有数据。
- 如果有事件发生，内核会返回产生了事件的连接，线程就会从**阻塞状态**返回，然后在用户态中再处理这些连接对应的业务即可。

**这里和libevent那里说的是一样的**。文件描述符非阻塞，然后使用select等着你来通知我可读，而不是我没次都去read试探。



当下开源软件能做到网络高性能的原因就是 I/O 多路复用吗？

是的，基本是基于 I/O 多路复用，用过 I/O 多路复用接口写网络程序的同学，肯定知道是面向过程的方式写代码的，这样的开发的效率不高。

**于是，大佬们基于面向对象的思想，对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。**

**大佬们还为这种模式取了个让人第一时间难以理解的名字**：**[Reactor 模式](https://www.zhihu.com/search?q=Reactor 模式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})**。

Reactor 翻译过来的意思是「反应堆」，可能大家会联想到物理学里的[核反应堆](https://www.zhihu.com/search?q=核反应堆&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})，实际上并不是的这个意思。

这里的反应指的是「**==对事件反应==**」，也就是**来了一个事件，Reactor 就有相对应的反应/响应**。

事实上，Reactor 模式也叫 `Dispatcher` 模式，我觉得这个名字更贴合该模式的含义，即 **I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程**。

Reactor 模式主要由 **Reactor** 和**处理资源池**这两个核心部分组成，它俩负责的事情如下：

- Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；
- 处理资源池负责处理事件，如 read -> 业务逻辑 -> send；

**Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于**：

- Reactor 的数量可以只有一个，也可以有多个；
- 处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；

将上面的两个因素排列组设一下，理论上就可以有 4 种方案选择：

- 单 Reactor 单进程 / 线程；
- 单 Reactor 多进程 / 线程；
- 多 Reactor 单进程 / 线程；
- 多 Reactor 多进程 / 线程；

其中，「**多 Reactor 单进程 / 线程**」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。

剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中：

- 单 Reactor 单进程 / 线程；
- 单 Reactor 多线程 / 进程；
- 多 Reactor 多进程 / 线程；

方案具体使用进程还是线程，要看使用的编程语言以及平台有关：

- Java 语言一般使用线程，比如 Netty;
- C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。

接下来，分别介绍这三个经典的 Reactor 方案。

### 单 Reactor 单进程 / 线程

一般来说，C 语言实现的是「**单 Reactor单进程**」的方案，因为 C 语编写完的程序，运行后就是一个独立的进程，不需要在进程中再创建线程。

而 Java 语言实现的是「**单 Reactor** ***单线程\***」的方案，因为 Java 程序是跑在 Java 虚拟机这个进程上面的，虚拟机中有很多线程，我们写的 Java 程序只是其中的一个线程而已。

我们来看看「**单 Reactor 单进程**」的方案示意图：

![image-20230304211936248](assets/image-20230304211936248.png)

作者：小林coding
链接：https://www.zhihu.com/question/26943938/answer/1856426252
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



可以看到进程里有 **Reactor、Acceptor、Handler** 这三个对象：

- Reactor 对象的作用是监听和分发事件；
- Acceptor 对象的作用是获取连接；
- Handler 对象的作用是处理业务；

对象里的 **==select(阻塞等待通知，被通知后建立连接或者进行读写业务)==**、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。

接下来，介绍下「单 Reactor 单进程」这个方案：

- Reactor 对象通过 select （IO 多路复用接口） 监听事件，**收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型**；

  * 建立连接--->Acceptor 对象

  * 读写业务--->Handler 对象

    就是简单的if-else来实现的。就是最开始学epoll写的那版代码。

    ```c
        int epfd = epoll_create(100);
        struct epoll_event ev;
        ev.events = EPOLLIN;   
        ev.data.fd = lfd;
        ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
        if(ret == -1)
        {
            perror("epoll_ctl");
            exit(0);
        }
    
        struct epoll_event evs[1024];
        int size = sizeof(evs) / sizeof(struct epoll_event);
        // 持续检测
        while(1)
        {
            // 调用一次, 检测一次
            int num = epoll_wait(epfd, evs, size, -1);
            printf("num=%d\n",num);
            
            for(int i=0; i<num; ++i)   
            {
                // 取出当前的文件描述符
                int curfd = evs[i].data.fd; //建立新连接或通信
                
                // 判断这个文件描述符是不是用于监听的
                if(curfd == lfd)  //是则代表有新的连接到来  Acceptor 对象
                {
                    // 建立新的连接
                    int cfd = accept(curfd, NULL, NULL);
       
                    ev.events = EPOLLIN; 
                    ev.data.fd = cfd;
                    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);  
                    if(ret == -1)
                    {
                        perror("epoll_ctl-accept");
                        exit(0);
                    }
                }
                else    //通信   Handler 对象
                {
                    // 处理通信的文件描述符
                    // 接收数据
                    char buf[1024];
                    memset(buf, 0, sizeof(buf));
                    int len = recv(curfd, buf, sizeof(buf), 0);
                    if(len == 0)
                    {
                        printf("客户端已经断开了连接\n");
                        // 将这个文件描述符从epoll模型中删除
                        epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); 
                        close(curfd); //一定要先删除再关闭，否则会删除失败
                    }
                }
            }
        }
    ```

    按照libevent和前面的介绍来说，这里文件描述符是否阻塞待讨论。

- 如果是连接建立的事件(if)，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；

- 如果不是连接建立事件(else)， 则交由当前连接对应的 Handler 对象来进行响应；

- Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的[业务流程](https://www.zhihu.com/search?q=业务流程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})。

单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑[进程间通信](https://www.zhihu.com/search?q=进程间通信&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})，也不用担心多进程竞争。

但是，这种方案存在 2 个缺点：

- 第一个缺点，因为只有一个进程，**无法充分利用 多核 CPU 的性能**；
- 第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的(也无法处理其他已连接客户端的业务)，**==如果业务处理耗时比较长，那么就造成响应的延迟==**；

所以，单 Reactor 单进程的方案**不适用计算机密集型的场景(IO吧？)，只适用于业务处理非常快速的场景**。

Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，**因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案**。

### 单 Reactor 多线程 / 多进程

如果要克服「单 Reactor 单线程 / 进程」方案的缺点，那么就需要引入多线程 / 多进程，这样就产生了**单 Reactor 多线程 / 多进程**的方案。

闻其名不如看其图，先来看看「单 Reactor 多线程」方案的示意图如下：

![image-20230304213233127](assets/image-20230304213233127.png)

详细说一下这个方案：

- Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，**具体分发给 Acceptor 对象还是 Handler 对象，还是要看收到的事件类型；**

  * 建立连接--->Acceptor 对象

  * 读写业务--->Handler 对象

    就是简单的if-else来实现的。

    ```c
        int epfd = epoll_create(100);
        struct epoll_event ev;
        ev.events = EPOLLIN;   
        ev.data.fd = lfd;
        ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
        if(ret == -1)
        {
            perror("epoll_ctl");
            exit(0);
        }
    
        struct epoll_event evs[1024];
        int size = sizeof(evs) / sizeof(struct epoll_event);
        // 持续检测
        while(1)
        {
            // 调用一次, 检测一次
            int num = epoll_wait(epfd, evs, size, -1);
            printf("num=%d\n",num);
            
            for(int i=0; i<num; ++i)   
            {
                // 取出当前的文件描述符
                int curfd = evs[i].data.fd; //建立新连接或通信
                
                // 判断这个文件描述符是不是用于监听的
                if(curfd == lfd)  //是则代表有新的连接到来  Acceptor 对象
                {
                    // 建立新的连接
                    int cfd = accept(curfd, NULL, NULL);
       
                    ev.events = EPOLLIN; 
                    ev.data.fd = cfd;
                    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);  
                    if(ret == -1)
                    {
                        perror("epoll_ctl-accept");
                        exit(0);
                    }
                }
                else    //通信   Handler 对象
                {
                   // receive client
                   // package data
                   // pthread_create()  // the vital thing is that we need send 
                   // package data to child thread
                   // receive data from child thread
                   // send to client
                }
            }
        }
    ```

    

- 如果是连接建立的事件(if)，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；

- 如果不是连接建立事件(else)， 则交由当前连接对应的 Handler 对象来进行响应；

上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：

- Handler 对象不再负责业务处理，**只负责数据的(从客户端或子线程)接收和发送(到子线程或客户端)**，Handler 对象通过 read 读取到数据后，**会将数据发给子线程里的 Processor 对象进行业务处理**；
- 子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，**接着由 Handler 通过 send 方法将响应结果发送给 client**；

单 Reator 多线程的方案优势在于**能够充分利用多核 CPU 的能**，那既然引入多线程，那么自然就带来了**多线程竞争资源**的问题。

例如，子线程完成业务处理后，要把结果传递给主线程的 Reactor 进行发送，这里涉及共享数据的竞争。

要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上[互斥锁](https://www.zhihu.com/search?q=互斥锁&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。

聊完单 Reactor 多线程的方案，接着来看看单 Reactor 多进程的方案。

**事实上，单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦(我不这么认为)，主要因为要考虑子进程 <-> [父进程](https://www.zhihu.com/search?q=父进程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端**。

而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，**==因此实际应用中也看不到单 Reactor 多进程的模式==**。

另外，「[单 Reactor](https://www.zhihu.com/search?q=单 Reactor&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})」的模式还有个问题，**因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，==在面对瞬间高并发的场景时==，容易成为性能的瓶颈的地方**。

### 多 Reactor 多进程 / 线程

要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产生了第 **多 Reactor 多进程 / 线程**的方案。

老规矩，闻其名不如看其图。多 Reactor 多进程 / 线程方案的示意图如下（以线程为例）：

![image-20230304214305407](assets/image-20230304214305407.png)

> 事实上，根据Memcache的实现，处理请求全部那一部分，我觉得都应该画到SubReactor那里面，他们是一体的，作者其实也是这个意思，只是我觉得画进去更好理解一些。

方案详细说明如下：

- 主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 **==accept==** 获取连接，将新的连接分配给某个子线程；

  > 连接可是在主线程就建立好的，只是会把这个通信的fd传递给子线程，这就涉及到线程数据的传递。最简单的是打包好一个结构体，复杂的(需要传递大量数据)像Memcache一样使用一个全局队列吧，然后线程间通信采用管道。看你怎么实现吧。

- **==子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件==**。

- 如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。

- **Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程**。

多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：

- **主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理**。
- **==主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端==**。

大名鼎鼎的两个开源软件 Netty 和 **==Memcache==** 都采用了「多 Reactor 多线程」的方案。

采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。

具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，**==而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象）==**，子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。

## 总结

作者：小林coding
链接：https://www.zhihu.com/question/26943938/answer/1856426252
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



常见的 Reactor 实现方案有三种。

第一种方案单 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，**而且处理业务逻辑的时间不能太长，否则会延迟响应**，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis 采用的是单 Reactor 单进程的方案。

第二种方案单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，**但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，==在面对瞬间高并发的场景时==，容易成为性能的瓶颈的地方**。

> 第一种面对瞬间高并发更不可以了。

第三种方案多 Reactor 多进程 / 线程，通过多个 Reactor 来解决了方案二的缺陷，**主 Reactor 只负责监听事件并建立连接，响应事件的工作交给了从 Reactor**，Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案，Nginx 则采用了类似于 「多 Reactor 多进程」的方案。

Reactor 可以理解为「**==来了事件操作系统通知应用进程，让应用进程来处理==**」，而 Proactor 可以理解为「**来了事件操作系统来处理，处理完再通知应用进程**」。

因此，真正的大杀器还是 Proactor，它是采用异步 I/O 实现的异步网络模型，感知的是已完成的读写事件，而不需要像 Reactor 感知到事件后，还需要调用 read 来从内核中获取数据。

不过，无论是 Reactor，还是 Proactor，都是一种基于「**==事件分发==**」的网络编程模式，区别在于 Reactor 模式是基于「**==待完成==**」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件。
